/*
 * readatminfo.c
 * readatminfo.txc - Read atmospheric info. Component of the
 *                   Transit program.
 *
 * Copyright (C) 2004 Patricio Rojo (pato@astro.cornell.edu)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 */

#include <transit.h>

const int maxeisoname=20;
static void askonenpt(struct onept *onept, struct atm_data *at, int rad);
static void askonemn (struct onept *onept, prop_isof *isof, int n, int nf);
static void telldefaults(struct isotopes *iso, struct atm_data *at);
static void atmerr(int max, char *file, int line);
static void notyet(int lin, char *file);
static int checknonmatch(struct transit *tr, struct atm_data *at, 
			 enum isodo *isodo);
static void invalidfield(char *line, char *file, int nmb,
			int fld, char *fldn);
static inline void checkposvalue(PREC_RES val, int field, char *file,
				 long line);


/* TD: atmosphere info  retrieval */
/*\fcnfh
   getatm: Get atmospheric parameters from a given file. It has to get
   all the extra isotopes data that was not in line database.

   @returns 0 On success
            -1 If no atmospheric info file was specified, and no
               defaults are allowed
	    -2 Default handling mode inexistent
	    -3 Something really bad happened!
	    -4 sum of abundances add up to more than 1
	    -5 requested isotope is an ignored one
*/
int getatm(struct transit *tr) /* Containing filename of atmosphere
				       info file */
{
  //'nmb' auxiliar variable for a number.
  int nmb,nrad,i;
  double sumq;
  //'at' and 'hints' are the atmospheric and hint's structure,
  //respectively
  struct transithint *th=tr->ds.th;
  struct onept *onept=&th->onept;
  static struct atm_data st_at;
  prop_samp *rads=&st_at.rads;
  memset(&st_at,0,sizeof(struct atm_data));
  tr->ds.at=&st_at;
  enum {invalid,given,ask,file} inp=invalid;
  float allowq;
  //'fp' and 'newiso' are initialized to avoid compiler output
  FILE *fp=NULL;
  int newiso=0;
  struct isotopes *iso=tr->ds.iso;

  //Pass atmospheric flags into info struct
  transitacceptflag(tr->fl,th->fl,TRU_ATMBITS);
  st_at.mass=th->mass;
  allowq = 1 - (tr->allowrq=th->allowrq);

  //If --onept parameter was given, then force a given one point.
  if(onept->one){
    tr->f_atm=NULL;
    inp=given;
    nrad=rads->n=1;
    rads->fct=1;
  }
  //otherwise if filename is not given or is "-", then use 1 point
  //default behavior
  else if(th->f_atm==NULL||strcmp(th->f_atm,"-")==0){
    tr->f_atm=th->f_atm;
    nrad=rads->n=1;
    rads->fct=1;

    //See how does the user wants the default to be handled
    switch(tr->fl&TRU_ATM1PBITS){
    case TRU_ATMNODEF:		/* Wants an error message */
      transiterror(TERR_SERIOUS|TERR_ALLOWCONT,
		   "getatm():: No atmospheric file specified\n");
      return -1;
      break;
    case TRU_ATMHARDC1P:	/* wants to use hard-coded values */
      sethcdef(tr,&st_at,rads);
      return 0;
      break;
    case TRU_ATMASK1P:		/* Wants to get values from standard
				   input */
      inp=ask;
      break;
    default:			/* Oops */
      transiterror(TERR_CRITICAL|TERR_ALLOWCONT,
		   "getatm():: Unexistent default handling mode (0x%x)\n"
		   "requested\n"
		   ,tr->fl&TRU_ATM1PBITS);
      return -2;
      break;
    }
  }
  //Otherwise if info is to be taken from file.
  else{
    //If a filename was given check its existence and that it can be
    //opened.
    if(verbfileopen(th->f_atm,&tr->fp_atm,"Atmospheric info ")!=1)
      exit(EXIT_FAILURE);
    tr->f_atm=th->f_atm;
    inp=file;
    fp=tr->fp_atm;

    //nrad willl be the amount of allocated radius so far.
    nrad=8;
    rads->n=0;
    rads->fct=1.0;
  }

  transitassert(inp==invalid,
		"This shouldn't have happened, 'inp' variable is\n"
		"not initialized in file %s, line %i\n"
		,__FILE__,__LINE__);

  //initialize TP arrays, by default temp and pressure are given in cgs.
  rads->v=(PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  st_at.atm.tfct=1;
  st_at.atm.pfct=1;
  st_at.atm.t= (PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  st_at.atm.p= (PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  rads->v[0]=1.0;

  //set p,t and neiso
  switch(inp){
  case given:
    newiso=st_at.n_niso=onept->ne;
    st_at.atm.t[0]=onept->t;
    st_at.atm.p[0]=onept->p;
    break;
  case ask:
    askonenpt(onept,&st_at,-1);
    newiso=st_at.n_niso;
    break;
  case file:
    //T and P will be read from the file, not knowing in advance how
    //many will be.\par
    //Same for the number of extra isotopes, first non-comment lines
    //begginning with i will contain fields with mass and name, 'newiso'
    //will contain the number of currently allocated extra isotopes,
    //'nmb' the total number of allocated isotopes.
    newiso=iso->n_i;
    break;
  default:			/* Just to avoid compiler output, it
				   should never happen */
    transiterror(TERR_CRITICAL,
		 "This is not happening in file %s (%li)\n"
		 ,__FILE__,__LINE__);
    break;
  }

  //Set values and allocate accordingly
  nmb=iso->n_e=iso->n_i+newiso;
  iso->isof=(prop_isof *)realloc(iso->isof,nmb*sizeof(prop_isof));
  iso->isof[iso->n_i].n=(char *)calloc(newiso*maxeisoname,sizeof(char));
  for(i=1;i<newiso;i++)
    iso->isof[iso->n_i+i].n=iso->isof[iso->n_i].n+i*maxeisoname;

  //set mass and names for the new guys
  switch(inp){
  case given:
    //if there were given an exact number of masses and names for the
    //extra isotopes.
    if(onept->nm==newiso){
      for(i=0;i<newiso;i++){
	strcpy(iso->isof[i+iso->n_i].n,onept->n[i]);
	iso->isof[i+iso->n_i].m=onept->m[i];
      }
    }
    else if(onept->nm>0){
      free(onept->m);
      free(onept->n[0]);
      free(onept->n);
    }
  case ask:
    //if there are new isotopes and they were not given exactly. Note
    //that no ignoring is possible if using interactive input.
    if(newiso>0&&onept->nm!=newiso)
      askonemn(onept,iso->isof,newiso, iso->n_i);
    st_at.n=onept->n;
    st_at.m=onept->m;
    break;
  case file:
    if((i=getmnfromfile(fp,&st_at,tr,nmb))<1){
      transiterror(TERR_SERIOUS,
		   "getmnfromfile() returned error code %i\n"
		   ,i);
      exit(EXIT_FAILURE);
    }
    break;
  default:
    break;
  }

  //Allocate isotope information for depth dependent information
  st_at.isov=(prop_isov *)calloc(nmb,sizeof(prop_isov));
  iso->isov=(prop_isov *)realloc(iso->isov,nmb*sizeof(prop_isov));
  st_at.mm=(double *)calloc(nrad,sizeof(double));
  for(i=0;i<nmb;i++){
    st_at.isov[i].d=(PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
    st_at.isov[i].q=(PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  }
  iso->isodo=(enum isodo *)realloc(iso->isodo,iso->n_e*sizeof(enum isodo));

  //get isotope abundance
  switch(inp){
  case given:
    if(onept->nq==nmb)
      for(i=0;i<nmb;i++){
	st_at.isov[i].q[0]=onept->q[i];
	iso->isodo[i]=fixed;
      }
    else if(onept->nq>0)
      free(onept->q);
  case ask:
    if(onept->nq!=nmb){
      onept->q=(PREC_ATM *)calloc(nmb,sizeof(PREC_ATM));
      for(i=0;i<nmb;i++){
	st_at.isov[i].q[0]=onept->q[i]
	  =askforposd(" %s abundance for isotope %s: "
		      ,st_at.mass?"Mass":"Number",iso->isof[i].n);
	if(onept->q[i]>=1){
	  transitprint(1,verblevel,
		       " Abundance given is greater than 1, hence ignoring this\n"
		       "isotope from now on\n");
	  iso->isodo[i]=ignore;
	}
	else
	  iso->isodo[i]=fixed;
      }
    }

    if((sumq=checkaddmm(st_at.mm,0,st_at.isov,iso->isof,nmb,st_at.mass,iso->isodo))
       <allowq)
      transiterror(TERR_WARNING,
		   "Abundances don't add up to 1: %.9g under one\n"
		   "point conditions\n"
		   ,sumq);
    //Calculate densities
    for(i=0;i<nmb;i++)
      st_at.isov[i].d[0]=stateeqnford(st_at.isov[i].q[0],
				      st_at.mm[0],
				      st_at.atm.p[0]*st_at.atm.pfct,
				      st_at.atm.t[0]*st_at.atm.tfct);
    break;
  case file:
    //All the extra isotopes are going to have density from file (cannot
    //be ignored or fixed.
    for(i=iso->n_i;i<iso->n_e;i++)
      iso->isodo[i]=atmfile;
    nrad=readatmfile(fp,tr,&st_at,rads,nrad);
    break;
  default:
    break;
  }

  //set required values in 'rads' structure
  rads->i=rads->v[0];
  rads->f=rads->v[rads->n-1];
  rads->o=1;
  rads->d=0;

  //If one point is being used, then let user know values
  if(nrad==1)
    telldefaults(iso,&st_at);

  transitASSERT(iso->n_e<iso->n_i,
		"Uyuyuyy!, number of isotopes after extension (%i)\n"
		"is smaller than number of isotopes before that (%i)\n"
		,iso->n_e,iso->n_i);


  //'tauiso' is the isotope index which tau() will calculate
  //afterwards. Just check that it is between boundaries.
  tr->tauiso=0;
  if(th->tauiso>=0&&
     th->tauiso<iso->n_i){
    if(iso->isodo[th->tauiso]==ignore&&tr->ds.ex->periso){
      transiterror(TERR_SERIOUS|TERR_ALLOWCONT,
		   "Selected isotope to compute tau (#%i: %s) was actually\n"
		   "ignored according to the atmospheric info\n"
		   ,th->tauiso,tr->ds.iso->isof[th->tauiso]);
      return -5;
    }
    else
      tr->tauiso=th->tauiso;
  }

  //Return succes and set progress indicator
  tr->pi|=TRPI_GETATM;
  return 0;
}


/* \fcnfh
   Computes mean molecular mass, check that sum of abundances is no
   bigger than 1, and returns it

   @returns sum of abundances
*/
double
checkaddmm(double *mm,		/* mean molecular mass stored here */
	   PREC_NREC r,		/* radius position */
	   prop_isov *isov,	/* variable isotope info */
	   prop_isof *isof,	/* fixed isotope info */
	   int n,		/* number of isotopes */
	   _Bool mass,		/* mass abundances? */
	   enum isodo *isodo)	/* whether to ignore isotopes */
{
  double sumq;
  int i;

  //Computes mean molecular mass
  sumq=*mm=0;
  for(i=0;i<n;i++){
    if(isodo[i]!=ignore){
      if(mass)
	*mm+=(isov[i].q[r])/(isof[i].m);
      else
	*mm+=(isov[i].q[r])*(isof[i].m);
      sumq+=isov[i].q[r];
    }
  }
  if(mass)
    *mm=1.0/(*mm);

  //Check that abundances make sense
  if(sumq>1){
    transiterror(TERR_SERIOUS,
		 "Sum of abundances of isotopes adds up to more\n"
		 "than 1: %g\n"
		 ,sumq);
  }

  return sumq;
}



/* \fcnfh
   Tell defaults when only one radius is being selected
 */
static void
telldefaults(struct isotopes *iso, 
	     struct atm_data *at)
{
  int i;

  transitprint(1,verblevel,
	       "You are using one point atmospheric conditions:\n"
	       " Temperature:         %g K\n"
	       " Pressure:            %g (cgs, dyne/cm2)\n"
	       " Mean molecular mass: %g (AMU)\n"
	       ,at->atm.t[0]*at->atm.tfct,at->atm.p[0]*at->atm.pfct,at->mm[0]);
  //Densities for all isotopes
  for(i=0;i<iso->n_e;i++)
    if(iso->isodo[i]!=ignore)
      transitprint(1,verblevel,
		   " %-8s: density %8g g/cm3\n"
		   ,iso->isof[i].n,at->isov[i].d[0]);
}


/* \fcnfh
   ask from standard input for temperature, pressure and number of
   extraisotopes, it stores both in 'onept' and in 'at' at radius 'rad'
 */
static void
askonenpt(struct onept *onept,
	  struct atm_data *at,
	  int rad)		/* Radius at which to store values,
				   negative if this a one point run */
{
  _Bool one=0;

  //If this is a onepoint model
  if (rad<0){
    one=1;
    rad=0;
  }

  onept->nm=onept->nq=0;

  //ask for number of extra isotopes if this is the zeroth radius only
  if(!rad)
    onept->ne=at->n_niso
      =askforposl(" Number of extra isotopes for which only abundance and\n"
		  "molecular mass has to be given: ");

  //ask for pressure
  if(one)
    onept->p=askforposd(" Atmospheric pressure, cgs units (1e6cgs=1atm): ");
  else
    onept->p=askforposd(" Atmsopheric pressure for radius %i%s: "
			  ,rad,rad?"":". cgs units (1e6cgs=1atm)");
  at->atm.p[rad]=onept->p;

  //ask for temperature
  if(one)
    onept->t=askforposd(" Atmospheric temperature, Kelvin degrees: ");
  else
    onept->t=askforposd(" Atmsopheric temperature for radius %i%s: "
			,rad,rad?"":". Kelvin degrees");
  at->atm.t[rad]=onept->t;

}

/* \fcnfh
   Ask mass and name for new isotopes
*/
static void
askonemn(struct onept *onept,	/* user given values are going to be
				   stored here */
	 prop_isof *isof,	/* Also stored here for use by the
				   program */
	 int n,			/* number of new isotopes, only partial
				   info for these is requested */
	 int nf)		/* Number of isotopes with full info */
{
  int i;
  char rc;

  //Allocate room in 'onept'. Room in 'isof' should be already be
  //allocated
  onept->m=(PREC_ZREC *)calloc(n,sizeof(PREC_ZREC));
  onept->n=(char **)calloc(n,sizeof(char *));
  onept->n[0]=(char *)calloc(n*maxeisoname,sizeof(char));
	
  //For each isotope ask for mass and name
  for(i=0;i<n;i++){
    onept->n[i]=onept->n[0]+i*maxeisoname;
    
    while(1){
      fprintf(stderr,
	      " Mass and name of extra isotope #%i (Order mandatory, "
	      "e.g. 12.011Carbon):\n  "
	      ,i+1);
      onept->m[i]=isof[i+nf].m=readds(stdin,&rc,
				      onept->n[i],maxeisoname-1);
      strcpy(isof[i+nf].n,onept->n[i]);
      if(rc=='q'){
	transitprint(0,verblevel,"User interrupt!\n");
	exit(EXIT_SUCCESS);
      }
      if(onept->m[i]<=0)
	fprintf(stderr," Invalid value %g, has to be positive\n",onept->m[i]);
      else if(!rc)
	break;
      fprintf(stderr,"Try again!\n");
    }
  }
}


/* \fcnfh
   get number of isotopes from file and set index 

   @returns number of lines read
*/
int
getmnfromfile(FILE *fp,
	      struct atm_data *at,
	      struct transit *tr,
	      int nmb)
{
  char rc;
  char line[maxline],*lp;
  int ison=0,i;
  struct isotopes *iso=tr->ds.iso;
  prop_isof *isof=iso->isof;
  enum isodo *isodo=iso->isodo;

  at->begline=0;
  enum isodo atisodo;
  at->isoeq=(int *)calloc(nmb,sizeof(int));
  at->m=(PREC_ZREC *)calloc(nmb,sizeof(PREC_ZREC));
  at->n=(char **)calloc(nmb,sizeof(char *));
  at->n[0]=(char *)calloc(nmb*maxeisoname,sizeof(char));
  at->isoeq[0]=-1;
  for(i=1;i<nmb;i++){
    at->n[i]=at->n[0]+i*maxeisoname;
    at->isoeq[i]=-1;
  }

  //while t,p data doesn't start
  while(1){
    while((rc=fgetupto(line,maxline,fp,&atmerr,tr->f_atm,at->begline++))
	  =='#'||rc=='\n');
    if(!rc) notyet(at->begline,tr->f_atm);
    if(rc=='u'){
      switch(line[1]){
      case 'r':
	at->rads.fct=atof(line+2);
	break;
      case 'p':
	at->atm.pfct=atof(line+2);
	break;
      case 't':
	at->atm.tfct=atof(line+2);
	break;
      }
      continue;
    }
    if(rc=='n'){
      storename(at,line+1);
      continue;
    }
    if(rc!='i')
      break;
    lp=line+1;
    while(*lp==' '||*lp=='\t') lp++;

    //for each field
    while(*lp){
      atisodo=atmfile;
      //Allocate if necessary
      if(ison==nmb){
	nmb<<=1;
	at->isoeq=(int *)realloc(at->isoeq,nmb*sizeof(int));
	at->m=(PREC_ZREC *)realloc(at->m,nmb*sizeof(PREC_ZREC));
	at->n=(char **)realloc(at->n,nmb*sizeof(char *));
	at->n[0]=(char *)realloc(at->n[0],nmb*maxeisoname*sizeof(char));
	for(i=1;i<nmb;i++)
	  at->n[i]=at->n[0]+i*maxeisoname;
	for(i=nmb/2;i<nmb;i++)
	  at->isoeq[i]=-1;
      }

      //get mass and name, checking that is correct. First see if this
      //isotope wants to be ignored.
      if(*lp=='!'){
	lp++;
	atisodo=ignore;
      }
      at->m[ison]=getds(lp,&rc,at->n[ison],maxeisoname-1);
      if(at->m[ison]<=0||at->n[ison]=='\0'){
	transiterror(TERR_SERIOUS,
		     "Invalid field in file %s, line %i while reading isotope"
		     " info at:\n%s\n"
		     ,tr->f_atm,at->begline,lp);
      }
      
      //now check if that isotope is one of the given in the lineinfo
      //file
      for(i=0;i<iso->n_i;i++){
	if(strcasecmp(at->n[ison],isof[i].n)==0){
	  at->isoeq[ison]=i;
	  if(isof[i].m!=at->m[ison])
	    transiterror(TERR_WARNING,
			 "Mass of isotope %s, is not the same\n"
			 "in the atmosphere file %s(%g) than in\n"
			 "the transition info file %s(%g)\n"
			 ,at->n[ison],tr->f_atm,at->m[ison],
			 tr->f_line,isof[i].m);
	  if(isodo[i]!=ignore)
	    isodo[i]=atisodo;
	  if(isodo[i]==ignore)
	    transitprint(2,verblevel,
			 "Ignoring isotope %s (%g AMU)\n"
			 ,isof[i].n,isof[i].m);
	  break;
	}
      }
      //count this as an isotope from the atmosphere file only if it was
      //not an ignored one.
      if(atisodo!=ignore)
	ison++;
      //skip over recently read field, and go to next field.
      while(*lp!=' '&&*lp!='\0') lp++;
      while(*lp==' '||*lp=='\t') lp++;
    }
  }
  if(!ison)
    transiterror(TERR_SERIOUS,
		 "No isotopes were found in atmosphere file, make sure to\n"
		 "specify them in a line starting with the letter 'i'.\n"
		 "First non-comment line read:\n%s\n"
		 ,line);
  at->begpos=ftell(fp)-strlen(line)-1;

  at->n_aiso=ison;
  nmb=ison;
  at->isoeq=(int *)realloc(at->isoeq,nmb*sizeof(int));
  at->m=(PREC_ZREC *)realloc(at->m,nmb*sizeof(PREC_ZREC));
  at->n=(char **)realloc(at->n,nmb*sizeof(char *));
  at->n[0]=(char *)realloc(at->n[0],nmb*maxeisoname*sizeof(char));
  for(i=1;i<nmb;i++)
    at->n[i]=at->n[0]+i*maxeisoname;

  //Resolve what to do with those isotopes that appear in the transition
  //database, but not in the atmosphere file.
  at->n_niso=checknonmatch(tr,at,isodo);

  nmb=iso->n_e=iso->n_i+at->n_niso;
  iso->isof=(prop_isof *)realloc(iso->isof,nmb*sizeof(prop_isof));
  iso->isof[iso->n_i].n=(char *)realloc(iso->isof[iso->n_i].n,
				      nmb*maxeisoname*sizeof(char));
  for(i=1;i<at->n_niso;i++)
    iso->isof[iso->n_i+i].n=iso->isof[iso->n_i].n+i*maxeisoname;

  nmb=iso->n_i;
  for(i=0;i<ison;i++)
    if(at->isoeq[i]==-1){
      at->isoeq[i]=nmb;
      iso->isof[nmb].m=at->m[i];
      strcpy(iso->isof[nmb++].n,at->n[i]);
    }

  transitASSERT(nmb!=iso->n_e,
		"Uyuyuyuyu! Problem in file %s, line %i,\n"
		"assertion failed: %i != %i!!\n"
		,__FILE__,__LINE__,nmb,iso->n_e);

  return at->begline;
}


/* \fcnfh
   It outputs error. Used when EOF is found before expected
*/
static void
notyet(int lin, char *file)
{
  transiterror(TERR_SERIOUS|TERR_ALLOWCONT,
	       "readatminfo:: EOF unexpectedly found at line %i of file %s\n"
	       "while no t,p data points have been read\n"
	       ,lin,file);
  exit(EXIT_FAILURE);
}


/* \fcnfh
   This function is called if a line of 'file' was longer than 'max'
   characters
*/
static void 
atmerr(int max,			/* Maxiumum length of an accepted line
				 */ 
       char *file,		/* File from which we were reading */
       int line)		/* Line who was being read */
{
  transiterror(TERR_SERIOUS|TERR_ALLOWCONT,
	       "Line %i of file '%s' has more than %i characters,\n"
	       "that is not allowed\n"
	       ,file,max);
  exit(EXIT_FAILURE);
}

/* \fcnfh
   Ask what to do with the isotopes that don't have a match in the just
   read atmosphere file

   return number of extra isotopes
*/
static int
checknonmatch(struct transit *tr, /* info about existent isotopes */
	      struct atm_data *at, /* info about just read isotopes */
	      enum isodo *isodo) /* what the user will want with each
				    isotope */ 
{
  int i,j,rn,ison=at->n_aiso;
  struct isotopes *iso=tr->ds.iso;

  //for each of the non-matched isotopes, ask if they want to be
  //matched, ignored or given a fixed value.
  for(i=0;i<iso->n_i;i++){
    if(isodo[i]==unclear){
      //If want to match then ask with what, if ignored or fixed it will
      //be dealt with later
      isodo[i]=askforposl("\nIsotope %s is not in atmosphere file, what do you\n"
			  "want to do? (1:match to some isotope, 2:ignore"
			  " this\nisotope, 3:give a fixed abundance value) "
			  ,iso->isof[i].n);
      if(isodo[i]>3){
	fprintf(stderr,"Invalid value, Try again!:\n");
	isodo[i--]=0;
	continue;
      }
      if(isodo[i]==atmfile){
	while(1){
	  rn=0;
	  for(j=0;j<ison;j++)
	    if(at->isoeq[j]==-1){
	      rn=1;
	      fprintf(stderr,"  %2i: %s (%gAMU)\n", j+1,at->n[j],at->m[j]);
	    }
	  if(!rn){
	    fprintf(stderr,
		    "Sorry but there are no isotopes to match with, so try\n"
		    "another option\n");
	    isodo[i--]=0;
	    continue;
	  }
	  j=askforposd("Select a isotope number from the above list to\n"
		       "match %s with: ",iso->isof[i].n);
	  if(at->isoeq[j-1]==-1){
	    at->isoeq[j-1]=i;
	    break;
	  }
	  else
	    fprintf(stderr,"Invalid value, Try again\n");
	}
      }
    }
  }

  rn=0;
  for(j=0;j<ison;j++)
    if(at->isoeq[j]==-1)
      rn++;

  return rn;
}


/* \fcnfh
   Read abundances and pressure for each isotope and radius

   @returns number of radius point
*/
int
readatmfile(FILE *fp,		/* File */
	    struct transit *tr, /* transit info */
	    struct atm_data *at, /* atmosphere info */
	    prop_samp *rads,	/* radius sampling */
	    int nrad)		/* number of allocated radii, note that
				   is not returned updated */
{
  //find abundance related quantities for each radius
  int lines=at->begline;
  PREC_NREC r=0;
  PREC_RES tmp;
  char rc;
  float allowq=1-tr->allowrq;
  double sumq;
  char line[maxline],*lp,*lp2;
  prop_isov *isov=at->isov;
  int *isoeq=at->isoeq;
  struct isotopes *iso=tr->ds.iso;
  enum isodo *isodo=iso->isodo;
  int i,nmb=iso->n_e;

  fseek(fp,at->begpos,SEEK_SET);
  while(1){
    //reallocate if necessary
    if(r==nrad){
      nrad<<=1;
      rads->v=(PREC_ATM *)realloc(rads->v,nrad*sizeof(PREC_ATM));
      at->atm.t= (PREC_ATM *)realloc(at->atm.t,nrad*sizeof(PREC_ATM));
      at->atm.p= (PREC_ATM *)realloc(at->atm.p,nrad*sizeof(PREC_ATM));
      at->mm=(double *)realloc(at->mm,nrad*sizeof(double));
      for(i=0;i<nmb;i++){
	isov[i].d=(PREC_ATM *)realloc(isov[i].d,
				      nrad*sizeof(PREC_ATM));
	isov[i].q=(PREC_ATM *)realloc(isov[i].q,
				      nrad*sizeof(PREC_ATM));
      }
    }

    //Skip comments and read next line
    while((rc=fgetupto(lp=line,maxline,fp,&atmerr,tr->f_atm,lines++))
	  =='#'||rc=='\n');
    //if it is end of file, stop loop
    if(!rc)
      break;

    tmp=rads->v[r]=strtod(lp,&lp2);
    checkposvalue(tmp,1,tr->f_atm,lines);
    if(lp==lp2) 
      invalidfield(line, tr->f_atm, lines, 1, "radius");
    tmp=at->atm.p[r]=strtod(lp2,&lp);
    checkposvalue(tmp,2,tr->f_atm,lines);
    if(lp==lp2)
      invalidfield(line, tr->f_atm, lines, 2, "pressure");
    tmp=at->atm.t[r]=strtod(lp,&lp2);
    checkposvalue(tmp,3,tr->f_atm,lines);
    if(lp==lp2)
      invalidfield(line, tr->f_atm, lines, 3, "temperature");

    //now read abundances for every isotope
    for(i=0;i<at->n_aiso;i++){
      transitASSERT(isoeq[i]<0||isoeq[i]>=iso->n_e,
		    "Assertion failed in file %s, line %i: %i!=[0,%i]\n"
		    ,__FILE__,__LINE__,isoeq[i],iso->n_e-1);
      tmp=isov[isoeq[i]].q[r]=strtod(lp2,&lp);
      checkposvalue(tmp, i+4, tr->f_atm, lines);

      if(lp==lp2)
	invalidfield(line, tr->f_atm, lines, 4+i, "isotope abundance");
      lp2=lp;
    }

    for(i=0;i<iso->n_i;i++)
      if(isodo[i]==fixed){
	if(!r){
	  isov[i].q[0]=askforposd(" %s abundance for isotope %s: "
				  ,at->mass?"Mass":"Number"
				  ,iso->isof[i].n);
	  if(isov[i].q[0]>=1){
	    fprintf(stderr," Abundance for any single isotope has to be"
		    " less than one\n Try Again!\n");
	    i--;
	  }
	}
	else
	  isov[i].q[r]=isov[i].q[0];
      }

    //calculate mean molecular mass and check whether abundances add up
    //correctly
    if((sumq=checkaddmm(at->mm+r,r,isov,iso->isof,nmb,at->mass,isodo))
       <allowq)
      transiterror(TERR_WARNING,
		   "In radius %g(%i), abundances don't add up to 1: %.9g\n"
		   ,at->rads.v[r],r,sumq);

    //Calculate densities
    for(i=0;i<nmb;i++)
      isov[i].d[r]=stateeqnford(isov[i].q[r],
				at->mm[r],
				at->atm.p[r]*at->atm.pfct,
				at->atm.t[r]*at->atm.tfct);
    r++;
  }
  rads->n=nrad=r;
  rads->v=(PREC_ATM *)realloc(rads->v,nrad*sizeof(PREC_ATM));
  at->atm.t= (PREC_ATM *)realloc(at->atm.t,nrad*sizeof(PREC_ATM));
  at->atm.p= (PREC_ATM *)realloc(at->atm.p,nrad*sizeof(PREC_ATM));
  at->mm=(double *)realloc(at->mm,nrad*sizeof(double));
  for(i=0;i<nmb;i++){
    isov[i].d=(PREC_ATM *)realloc(isov[i].d,
				  nrad*sizeof(PREC_ATM));
    isov[i].q=(PREC_ATM *)realloc(isov[i].q,
				  nrad*sizeof(PREC_ATM));
  }

  return nrad;
}

/* \fcnfh
   Check that val is positive
*/
static inline void 
checkposvalue(PREC_RES val,	/* value to check */
	      int field,	/* field where it was read */
	      char *file,	/* file from which it was read */
	      long line)	/* line from which it was read */
{
  if(val<0)
    transiterror(TERR_SERIOUS,
		 "While reading the %ith field in line %li of atmosphere\n"
		 "file %s, a negative value was found (%g)\n"
		 ,field,line-1,file,val);
}


/* \fcnfh
   Stores info about the atmopshere file
*/
void
storename(struct atm_data *at,
	  char *line)
{
  while(*line==' '||*line=='\t') line++;

  int len=strlen(line);

  //only store name if it has not been stored before
  if(!at->info){
    at->info=calloc(len+1,sizeof(char));
    strcpy(at->info,line);
  }
}



/* \fcnfh
   print out an error, it is called by readdatarng if one of the field
   with transition info is invalid

*/
static void
invalidfield(char *line,	/* Contents of the line */
	     char *file,	/* File name */
	     int nmb,		/* File number */
	     int fld,		/* field with the error */
	     char *fldn)	/* Name of the field */
{
  transiterror(TERR_SERIOUS|TERR_ALLOWCONT,
	       "Line %i of file '%s': Field %i (%s) has\n"
	       " not a valid value:\n%s\n"
	       ,nmb,file,fld,fldn,line);
  exit(EXIT_FAILURE);
}


/* \fcnfh
   Set hard coded values 
*/
void
sethcdef(struct transit *tr,
	 struct atm_data *at,
	 prop_samp *rads)
{
  //Hard coded values.
  //'hc\_t' temperature.
  //'hc\_mass' masses.
  //'hc\_abund' is the abundance of the first isotope, the rest are
  //just set at zero in the hardcode modality.
  PREC_ZREC hc_t=1350;
  PREC_ATM hc_pres=1.0e3;
  PREC_ATM hc_abund=6.5e-4;
  PREC_ATM hc_meanmass=2.3;

  int nrad=rads->n;
  rads->v=(PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  at->atm.tfct=1;
  at->atm.pfct=1;
  at->atm.t= (PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  at->atm.p= (PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  at->mm= (PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  rads->v[0]=1.0;

  at->n_niso=0;
  struct isotopes *iso=tr->ds.iso;
  int nmb=iso->n_e=iso->n_i+at->n_niso;
  at->isov=(prop_isov *)calloc(nmb,sizeof(prop_isov));

  at->atm.t[0]=hc_t;
  at->atm.p[0]=hc_pres;
  at->mm[0]=hc_meanmass;
  for(int i=0;i<nmb;i++){
    at->isov[i].d=(PREC_ATM *)calloc(1,sizeof(PREC_ATM));
    at->isov[i].d[0]=stateeqnford(hc_abund,hc_meanmass,
				    hc_pres,hc_t);
    hc_abund=0;
  }
  telldefaults(iso,at);
}


/* \fcnfh
   frees memory from the atmosphere structure

   @returns 0 on success
*/
int
freemem_atmosphere(struct atm_data *at,
		   long *pi)
{
  //free structures
  free_samp(&at->rads);
  free_isov(at->isov);
  free_atm(&at->atm);


  //free arrays
  free(at->isov);
  free(at->mm);
  free(at->n[0]);
  free(at->n);
  free(at->m);
  free(at->isoeq);
  free(at->isodo);
  free(at->info);


  //clear progress indicator and return success
  *pi&=~(TRPI_GETATM);
  return 0;
}


/* \fcnfh
   saves onept structure's array
*/
void
saveonept_arr(FILE *out,
	      struct onept *onept)
{
  if(onept->ne<=0)
    return;
  fwrite(onept->n[0],1,maxeisoname*onept->ne,out);
  fwrite(onept->m,sizeof(PREC_ZREC),onept->ne,out);
}


/* \fcnfh
   restores onept structure's arrays

   @returns 0 on success
            -1 if not all the expected information is read
	    -2 if info read is wrong
	    -3 if cannot allocate memory
	    1 if information read was suspicious
*/
int
restonept_arr(FILE *in,
	      struct onept *onept)
{
  if(onept->ne<=0)
    return 0;

  if((onept->n=(char **)calloc(onept->ne,sizeof(char *)))==NULL ||
     (onept->n[0]=(char *)calloc(onept->ne,sizeof(char)))==NULL ||
     (onept->m=(PREC_ZREC *)calloc(onept->ne,sizeof(PREC_ZREC)))==NULL)
    return -3;

  int i;
  for(i=1;i<onept->ne;i++)
    onept->n[i]=onept->n[0]+i*maxeisoname;

  if(fread(onept->n[0],1,maxeisoname*onept->ne,in)!=maxeisoname*onept->ne)
    return -1;

  if(fread(onept->m,sizeof(PREC_ZREC),onept->ne,in)!=onept->ne)
    return -1;

  return 0;
}
