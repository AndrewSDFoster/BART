/*
 * readatminfo.c
 * readatminfo.txc - Read atmospheric info. Component of the
 *                   Transit program.
 *
 * Copyright (C) 2004 Patricio Rojo (pato@astro.cornell.edu)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 */

#include <transit.h>


const int maxeisoname=20;
static void askonenpt(struct onept *onept, struct atm_data *at, int rad);
static void askonemn (struct onept *onept, prop_isof *isof, int n, int nf);
static void telldefaults(struct transit *tr, struct atm_data *at);

/* TD: atmosphere info  retrieval */
/*\fcnfh
   getatm: Get atmospheric parameters from a given file. It has to get
   all the extra isotopes data that was not in line database.

   @returns 0 On success
            -1 If no atmospheric info file was specified, and no
               defaults are allowed
	    -2 Default handling mode inexistent
	    -3 Something really bad happened!
	    -4 sum of abundances add up to more than 1
*/
int getatm(struct transit *tr) /* Containing filename of atmosphere
				       info file */
{
  //'nmb' auxiliar variable for a number.
  int nmb,nrad,i;
  double sumq;
  //'at' and 'hints' are the atmospheric and hint's structure,
  //respectively
  struct transithint *th=tr->ds.th;
  struct onept *onept=&th->onept;
  static struct atm_data st_at;
  prop_samp *rads=&st_at.rads;
  memset(&st_at,0,sizeof(struct atm_data));
  tr->ds.at=&st_at;
  enum {invalid,given,ask,file} inp=invalid;

  //Hard coded values.
  //'hc\_t' temperature.
  //'hc\_mass' masses.
  //'hc\_abund' is the abundance of the first isotope, the rest are
  //just set at zero in the hardcode modality.
  PREC_ZREC hc_t=1350;
  PREC_ATM hc_pres=1.0e3;
  PREC_ATM hc_abund=6.5e-4;
  PREC_ATM hc_meanmass=2.3;

  //Pass atmospheric flags into info struct
  transitacceptflag(tr->fl,th->fl,TRU_ATMBITS);
  transitaccepthint(st_at.mass,th->mass,th->na,TRH_MASS);

  //If --onept parameter was given, then force a given one point.
  if(onept->one){
    tr->f_atm=NULL;
    inp=given;
    nrad=rads->n=1;

  }
  //otherwise if filename is not given or is "-", then use 1 point
  //default behavior
  else if(th->f_atm==NULL||strcmp(th->f_atm,"-")==0){
    transitaccepthint(tr->f_atm,th->f_atm,th->na,TRH_FA);
    nrad=rads->n=1;

    //See how does the user wants the default to be handled
    switch(tr->fl&TRU_ATM1PBITS){
    case TRU_ATMNODEF:		/* Wants an error message */
      transiterror(TERR_SERIOUS|TERR_ALLOWCONT,
		   "getatm():: No atmospheric file specified");
      return -1;
      break;
    case TRU_ATMHARDC1P:	/* wants to use hard-coded values */
      rads->v=(PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
      st_at.atm.t= (PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
      st_at.atm.p= (PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
      rads->v[0]=1.0;

      st_at.n_niso=0;
      nmb=tr->n_e=tr->n_i+st_at.n_niso;
      st_at.isov=(prop_isov *)calloc(nmb,sizeof(prop_isov));

      st_at.atm.t[0]=hc_t;
      st_at.atm.p[0]=hc_pres;
      st_at.mm=hc_meanmass;
      for(i=0;i<nmb;i++){
	st_at.isov[i].d=(PREC_ATM *)calloc(1,sizeof(PREC_ATM));
	st_at.isov[i].d[0]=stateeqnford(hc_abund,hc_meanmass,
					hc_pres,hc_t);
	hc_abund=0;
      }
      telldefaults(tr,&st_at);
      return 0;
      break;
    case TRU_ATMGIVEN1P:	/* Wants to get it from hints->onept */
      inp=given;
      break;
    case TRU_ATMASK1P:		/* Wants to get values from standard
				   input */
      inp=ask;
      break;
    default:			/* Oops */
      transiterror(TERR_CRITICAL|TERR_ALLOWCONT,
		   "getatm():: Unexistent default handling mode (0x%x)\n"
		   "requested\n"
		   ,tr->fl&TRU_ATM1PBITS);
      return -2;
      break;
    }
  }
  //Otherwise if info is to be taken from file.
  else{
    //If a filename was given check its existence and that it can be
    //opened.
    verbfileopen(th->f_atm,&tr->fp_atm,"Atmospheric info ");
    inp=file;

    //nrad willl be the amount of allocated radius so far.
    nrad=8;
    rads->n=0;

    transiterror(TERR_CRITICAL,
		 "Read atmospheric data file not yet implemented!\n");
  }

  if(inp==invalid)
    transiterror(TERR_CRITICAL,
		 "This shouldn't have happened, 'inp' variable is\n"
		 "not initialized in file %s, line %i\n"
		 ,__FILE__,__LINE__);

  rads->v=(PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  st_at.atm.t= (PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  st_at.atm.p= (PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  rads->v[0]=1.0;

  //set p,t and neiso
  switch(inp){
  case given:
    newiso=st_at.n_niso=onept->ne;
    st_at.atm.t[0]=onept->t;
    st_at.atm.p[0]=onept->p;
    break;
  case ask:
    askonenpt(onept,&st_at,-1);
    newiso=st_at.n_niso;
    break;
  case file:
    //T and P will be read from the file, not knowing in advance how
    //many will be.\par
    //Same for the number of extra isotopes, first non-comment lines
    //begginning with i will contain fields with mass and name, 'newiso'
    //will contain the number of currently allocated extra isotopes
    newiso=8;
  default:			/* Just to avoid compiler output */
    break;
  }

  //Set values and allocate accordingly
  nmb=tr->n_e=tr->n_i+newiso;
  st_at.isov=(prop_isov *)calloc(nmb,sizeof(prop_isov));
  tr->isof=(prop_isof *)realloc(tr->isof,nmb*sizeof(prop_isof));
  tr->isov=(prop_isov *)realloc(tr->isov,nmb*sizeof(prop_isov));
  for(i=0;i<nmb;i++){
    st_at.isov[i].d=(PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
    st_at.isov[i].q=(PREC_ATM *)calloc(nrad,sizeof(PREC_ATM));
  }
  tr->isof[tr->n_i].n=(char *)calloc(newiso*maxeisoname,sizeof(char));
  for(i=1;i<newiso;i++)
    tr->isof[tr->n_i+i].n=tr->isof[tr->n_i].n+i*maxeisoname;
  /* TD from here: keep track were I'm allocating nrad */

  //set mass and names for the new guys
  switch(inp){
  case given:
    //if there were given an exact number of masses and names for the
    //extra isotopes.
    if(onept->nm==onept->ne){
      for(i=0;i<newiso;i++){
	strcpy(tr->isof[i+tr->n_i].n,onept->n[i]);
	tr->isof[i+tr->n_i].m=onept->m[i];
      }
    }
    else if(onept->nm>0){
      free(onept->m);
      free(onept->n[0]);
      free(onept->n);
    }
  case ask:
    //if there are new isotopes and they were not given exactly
    if(newiso>0&&onept->nm!=newiso)
      askonemn(onept,tr->isof,newiso, tr->n_i);
    break;
  case file:
    /* TD from here */
  }

  //get isotope abundance
  switch(inp){
  case given:
    if(onept->nq==nmb){
      for(i=0;i<nmb;i++)
	st_at.isov[i].q[0]=onept->q[i];
      break;
    }
    if(onept->nq>0)
      free(onept->q);
  case ask:
    onept->q=(PREC_ATM *)calloc(nmb,sizeof(PREC_ATM));
    for(i=0;i<nmb;i++){
      st_at.isov[i].q[0]=onept->q[i]
	=askforposd(" %s abundance for isotope %s: "
		    ,st_at.mass?"Mass":"Number",tr->isof[i].n);
      if(onept->q[i]>=1){
	fprintf(stderr," Abundance for any single isotope has to be"
		" less than one\n Try Again!\n");
	i--;
      }
    }
    break;
  }

  //find mean molecular mass
  sumq=st_at.mm=0;
  for(i=0;i<nmb;i++){
    if(st_at.mass)
      st_at.mm+=(onept->q[i])/(tr->isof[i].m);
    else
      st_at.mm+=(onept->q[i])*(tr->isof[i].m);
    sumq+=onept->q[i];
  }
  if(st_at.mass)
    st_at.mm=1.0/st_at.mm;

  //Check that abundances make sense
  if(sumq>1){
    transiterror(TERR_SERIOUS|TERR_ALLOWCONT,
		 "Sum of abundances of isotopes adds up to more\n"
		 "than 1: %g\n"
		 ,sumq);
    return -4;
  }
  if(sumq<1)
    transiterror(TERR_WARNING,
		 "Sum of all abundances add up to less than 1: %.9g\n"
		 ,sumq);

  //Calculate densities
  for(i=0;i<nmb;i++)
    st_at.isov[i].d[0]=stateeqnford(st_at.isov[i].q[0],
				    st_at.mm,
				    st_at.atm.p[0],
				    st_at.atm.t[0]);

  //If one point is being used, then let user know values
  if(nrad==1)
    telldefaults(tr,&st_at);

  transitASSERT(tr->n_e<tr->n_i,
		"Uyuyuyy!, number of isotopes after extension (%i)\n"
		"is smaller than number of isotopes before that (%i)\n"
		,tr->n_e,tr->n_i);


  //Return succes and set progress indicator
  tr->pi|=TRPI_GETATM;
  return 0;
}


/* \fcnfh
   Tell defaults when only one radius is being selected
 */
static void
telldefaults(struct transit *tr, 
	     struct atm_data *at)
{
  int i;

  transitprint(1,verblevel,
	       "You are using one point atmospheric conditions:\n"
	       " Temperature:         %g K\n"
	       " Pressure:            %g (cgs, dyne/cm2)\n"
	       " Mean molecular mass: %g (AMU)\n"
	       ,at->atm.t[0],at->atm.p[0],at->mm);
  //Densities for all isotopes
  for(i=0;i<tr->n_e;i++)
    transitprint(1,verblevel,
		 " %-8s: density %8g g/cm3\n"
		 ,tr->isof[i].n,at->isov[i].d[0]);
}


/* \fcnfh
   ask from standard input for temperature, pressure and number of
   extraisotopes, it stores both in 'onept' and in 'at' at radius 'rad'
 */
static void
askonenpt(struct onept *onept,
	  struct atm_data *at,
	  int rad)		/* Radius at which to store values,
				   negative if this a one point run */
{
  _Bool one=0;

  //If this is a onepoint model
  if (rad<0){
    one=1;
    rad=0;
  }

  onept->nm=onept->nq=0;

  //ask for number of extra isotopes if this is the zeroth radius only
  if(!rad)
    onept->ne=at->n_niso
      =askforposl(" Number of extra isotopes for which only abundance and\n"
		  "molecular mass has to be given: ");

  //ask for pressure
  if(one)
    onept->p=askforposd(" Atmospheric pressure, cgs units (1e-3cgs=1atm): ");
  else
    onept->p=askforposd(" Atmsopheric pressure for radius %i%s: "
			  ,rad,rad?"":". cgs units (1e-3cgs=1atm)");
  at->atm.p[rad]=onept->p;

  //ask for temperature
  if(one)
    onept->t=askforposd(" Atmospheric temperature, Kelvin degrees: ");
  else
    onept->t=askforposd(" Atmsopheric temperature for radius %i%s: "
			,rad,rad?"":". Kelvin degrees");
  at->atm.t[rad]=onept->t;

}

/* \fcnfh
   Ask mass and name for new isotopes
*/
static void
askonemn(struct onept *onept,	/* user given values are going to be
				   stored here */
	 prop_isof *isof,	/* Also stored here for use by the
				   program */
	 int n,			/* number of new isotopes, only partial
				   info for these is requested */
	 int nf)		/* Number of isotopes with full info */
{
  int i;
  char rc;

  //Allocate room in 'onept'. Room in 'isof' should be already be
  //allocated
  onept->m=(PREC_ZREC *)calloc(n,sizeof(PREC_ZREC));
  onept->n=(char **)calloc(n,sizeof(char));
  onept->n[0]=(char *)calloc(n*maxeisoname,sizeof(char));
	
  //For each isotope ask for mass and name
  for(i=0;i<n;i++){
    onept->n[i]=onept->n[0]+i*maxeisoname;
    
    while(1){
      fprintf(stderr,
	      " Mass and name of extra isotope #%i (Order mandatory, "
	      "e.g. 12.011Carbon):\n  "
	      ,i+1);
      onept->m[i]=isof[i+nf].m=readds(stdin,&rc,
				      onept->n[i],maxeisoname-1);
      strcpy(isof[i+nf].n,onept->n[i]);
      if(rc=='q'){
	transitprint(0,verblevel,"User interrupt!\n");
	exit(EXIT_SUCCESS);
      }
      if(onept->m[i]<=0)
	fprintf(stderr," Invalid value %g, has to be positive\n",onept->m[i]);
      else if(!rc)
	break;
      fprintf(stderr,"Try again!\n");
    }
  }
}



/* \fcnfh
   ask for a positive double value from stdin with the question 'fmt';
   to stderr
*/
double
askforposd(char *fmt,		/* Question asked */
	   ...)			/* parameters for the question if any */
{
  va_list ap;
  va_start(ap,fmt);
  double val;
  char rc;

  while(1){
    vfprintf(stderr,fmt,ap);
    val=readd(stdin,&rc);
    if(rc=='q'){
      transitprint(0,verblevel,"User interrupt!\n");
      exit(EXIT_SUCCESS);
    }
    if(val<=0)
      fprintf(stderr," Invalid value %g, it has to be positive\n",val);
    else if(!rc)
      break;
    fprintf(stderr,"Try again!\n");
  }
  va_end(ap);

  return val;
}

/* \fcnfh
   ask for a positive long value from stdin with the question 'fmt';
   to stderr
*/
long
askforposl(char *fmt,		/* Question asked */
	   ...)			/* parameters for the question if any */
{
  va_list ap;
  va_start(ap,fmt);
  long val;
  char rc;

  while(1){
    vfprintf(stderr,fmt,ap);
    val=readl(stdin,&rc);
    if(rc=='q'){
      transitprint(0,verblevel,"User interrupt!\n");
      exit(EXIT_SUCCESS);
    }
    if(val<=0)
      fprintf(stderr," Invalid value %li, it has to be positive\n",val);
    else if(!rc)
      break;
    fprintf(stderr,"Try again!\n");
  }
  va_end(ap);

  return val;
}

