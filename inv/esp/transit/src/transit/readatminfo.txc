/*
 * readatminfo.c
 * readatminfo.txc - Read atmospheric info. Component of the
 *                   Transit program.
 *
 * Copyright (C) 2004 Patricio Rojo (pato@astro.cornell.edu)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 */

#include <transit.h>


/* TD: atmosphere info  retrieval */
/*\fcnfh
   getatm: Get atmospheric parameters from a given file. It has to get
   all the extra isotopes data that was not in line database.

   @returns 0 On success
            -1 If no atmospheric info file was specified, and no
               defaults are allowed
	    -2 Default handling mode inexistent
	    -3 Something really bad happened!
*/
int getatm(struct transit *tr) /* Containing filename of atmosphere
				       info file */
{
  //'nmb' auxiliar variable for a number.
  int nmb,i;
  double val;
  char rc;
  //'at' and 'hints' are the atmospheric and hint's structure,
  //respectively
  struct transithint *th=tr->ds.th;
  struct onept *onept;
  static struct atm_data st_at;
  memset(&st_at,0,sizeof(struct atm_data));
  tr->ds.at=&st_at;

  int maxeisoname=20;

  //Hard coded values.
  //'hc\_t' temperature.
  //'hc\_mass' masses.
  //'hc\_abund' is the abundance of the first isotope, the rest are
  //just set at zero in the hardcode modality.
  PREC_ZREC hc_t=1350;
  PREC_ATM hc_pres=1.0e3;
  PREC_ATM hc_abund=6.5e-4;
  PREC_ATM hc_meanmass=2.3;

  //Pass atmospheric flags into info struct
  transitacceptflag(tr->fl,th->fl,TRU_ATMBITS);

  //If filename is not given or is "-", then do not use atmosphere file
  //and use defaults instead. 
  if(th->f_atm==NULL||strcmp(th->f_atm,"-")==0){
    transitaccepthint(tr->f_atm,th->f_atm,th->na,TRH_FA);
    st_at.rads.n=1;
    st_at.rads.v=(PREC_ATM *)calloc(st_at.rads.n,sizeof(PREC_ATM));
    st_at.atm.t=(PREC_ATM  *)calloc(st_at.rads.n,sizeof(PREC_ATM));
    st_at.atm.p=(PREC_ATM  *)calloc(st_at.rads.n,sizeof(PREC_ATM));
    st_at.rads.v[0]=1.0;

    transitDEBUG(20,verblevel,
		 "First isotope: %s\n"
		 ,tr->isof[0].n);

    //See which way does the user wants the default to be handled
    switch(tr->fl&TRU_ATM1PBITS){
    case TRU_ATMNODEF:		/* Wants an error message */
      transiterror(TERR_SERIOUS|TERR_ALLOWCONT,
		   "getatm():: No atmospheric file specified");
      return -1;
      break;

    case TRU_ATMHARDC1P:	/* wants to use hard-coded values */
      st_at.n_niso=0;
      nmb=tr->n_e=tr->n_i+st_at.n_niso;
      st_at.isov=(prop_isov *)calloc(nmb,sizeof(prop_isov));

      st_at.atm.t[0]=hc_t;
      st_at.atm.p[0]=hc_pres;
      st_at.mm=hc_meanmass;
      for(i=0;i<nmb;i++){
	st_at.isov[i].d=(PREC_ATM *)calloc(1,sizeof(PREC_ATM));
	st_at.isov[i].d[0]=stateeqnford(hc_abund,hc_meanmass,
					hc_pres,hc_t);
	hc_abund=0;
      }
      break;

    case TRU_ATMGIVEN1P:	/* Wants to get it from hints->onept */
      st_at.n_niso=onept->ne;
      nmb=tr->n_e=tr->n_i+st_at.n_niso;
      st_at.isov=(prop_isov *)calloc(nmb,sizeof(prop_isov));
      //allocate room for 'tr->isov(f)'
      tr->isof=(prop_isof *)realloc(tr->isof,nmb*sizeof(prop_isof));
      tr->isov=(prop_isov *)realloc(tr->isov,nmb*sizeof(prop_isov));
      tr->isof[tr->n_i].n=(char *)calloc(st_at.n_niso*maxeisoname,sizeof(char));

      onept=&th->onept;
      st_at.atm.t[0]=onept->t;
      st_at.atm.p[0]=onept->p;

      //if there were given an exact number of masses and names for the
      //extra isotopes.
      if(onept->nm==onept->ne){
	for(i=0;i<st_at.n_niso;i++){
	  strcpy(tr->isof[i+tr->n_i].n,onept->n[i]);
	  tr->isof[i+tr->n_i].m=onept->m[i];
	}
  /*
    TD from here: calculate mean average and store it in st_at.mm
   */
      }
      else if(onept->nm>0){
	free(onept->m);
	free(onept->n[0]);
	free(onept->n);
      }

      //if there were given an exact number of isotopes.
      if(onept->nq==nmb){
	for(i=0;i<nmb;i++){
	  st_at.isov[i].d=(PREC_ATM *)calloc(1,sizeof(PREC_ATM));
	  st_at.isov[i].q=(PREC_ATM *)calloc(1,sizeof(PREC_ATM));
	  st_at.isov[i].q[0]=onept->q[i];
	  st_at.isov[i].d[0]=stateeqnford(onept->q[i],st_at.mm,
					  onept->p,onept->t);
	}
      }
      else if(onept->nq>0)
	free(onept->q);

    case TRU_ATMASK1P:		/* Wants to get values from standard input */
      onept=&th->onept;
      if((tr->fl&TRU_ATMASK1P)==TRU_ATMASK1P){
	onept->nm=onept->nq=0;
	while(1){
	  fprintf(stderr,
		  " Number of extra isotopes for which only abundance and\n"
		  "molecular mass has to be given: ");
	  onept->ne=st_at.n_niso=readl(stdin,&rc);
	  if(!rc) break;
	  if(rc=='q'){
	    transitprint(0,verblevel,"User interrupt!\n");
	    exit(EXIT_SUCCESS);
	  }
	  fprintf(stderr,"Try again!\n");
	}
	nmb=tr->n_e=tr->n_i+st_at.n_niso;
	st_at.isov=(prop_isov *)calloc(nmb,sizeof(prop_isov));
	//Allocate room in 'tr->isov(f)'
	tr->isof=(prop_isof *)realloc(tr->isof,nmb*sizeof(prop_isof));
	tr->isov=(prop_isov *)realloc(tr->isov,nmb*sizeof(prop_isov));
	tr->isof[tr->n_i].n=(char *)calloc(st_at.n_niso*maxeisoname,sizeof(char));

	while(1){
	  fprintf(stderr," Atmospheric pressure, cgs units (1e-3cgs=1atm): ");
	  onept->p=st_at.atm.p[0]=readd(stdin,&rc);
	  if(!rc) break;
	  if(rc=='q'){
	    transitprint(0,verblevel,"User interrupt!\n");
	    exit(EXIT_SUCCESS);
	  }
	  fprintf(stderr,"Try again!\n");
	}
	while(1){
	  fprintf(stderr," Atmospheric temperature, Kelvin degrees: ");
	  onept->t=st_at.atm.t[0]=readd(stdin,&rc);
	  if(!rc) break;
	  if(rc=='q'){
	    transitprint(0,verblevel,"User interrupt!\n");
	    exit(EXIT_SUCCESS);
	  }
	  fprintf(stderr,"Try again!\n");
	}
      }

      //if there are new isotopes and they were not given exactly
      if(st_at.n_niso>0&&onept->nm!=st_at.n_niso){
	//Allocate room in 'onept'
	onept->n=(char **)calloc(st_at.n_niso,sizeof(char));
	onept->n[0]=(char *)calloc(st_at.n_niso*maxeisoname,sizeof(char));
	onept->m=(PREC_ZREC *)calloc(st_at.n_niso,sizeof(PREC_ZREC));
	
	//For each isotope ask for mass and name
	for(i=0;i<st_at.n_niso;i++){
	  onept->n[i]=onept->n[0]+i*maxeisoname;
	  tr->isof[i].n=tr->isof[0].n+i*maxeisoname;
	  while(1){
	    fprintf(stderr,
		    " Mass and name of extra isotope #%i (Order mandatory,\n"
		    "e.g. 12.011Carbon): "
		    ,i+1);
	    onept->m[i]=tr->isof[i+tr->n_i].m=readds(stdin,&rc,
						  onept->n[i],maxeisoname-1);
	    strcpy(tr->isof[i+tr->n_i].n,onept->n[i]);
	    if(!rc) break;
	    if(rc=='q'){
	      transitprint(0,verblevel,"User interrupt!\n");
	      exit(EXIT_SUCCESS);
	    }
	    fprintf(stderr,"Try again!\n");
	  }
	}
  /*
    TD from here: calculate mean average and store it in st_at.mm
   */
      }

      //If abundances were not given exactly for each isotope
      if(onept->nq!=nmb){
	onept->q=(PREC_ATM *)calloc(nmb,sizeof(PREC_ATM));
	for(i=0;i<nmb;i++){
	  st_at.isov[i].d=(PREC_ATM *)calloc(1,sizeof(PREC_ATM));
	  st_at.isov[i].q=(PREC_ATM *)calloc(1,sizeof(PREC_ATM));
	  while(1){
	    fprintf(stderr," Mass abundance for isotope %s: "
		    ,tr->isof[i].n);
	    onept->q[i]=val=readd(stdin,&rc);
	    if(!rc) break;
	    if(rc=='q'){
	      transitprint(0,verblevel,"User interrupt!\n");
	      exit(EXIT_SUCCESS);
	    }
	    fprintf(stderr,"Try again!\n");
	  }
	  st_at.isov[i].q[0]=val;
	  st_at.isov[i].d[0]=stateeqnford(val,st_at.mm,
					  st_at.atm.p[0],
					  st_at.atm.t[0]);
	}
      }

      break;

    default:			/* Oops */
      transiterror(TERR_CRITICAL|TERR_ALLOWCONT,
		   "getatm():: Unexistent default handling mode (0x%x)\n"
		   "requested\n"
		   ,tr->fl&TRU_ATM1PBITS);
      return -2;
      break;
    }

    //Let user know that defaults are being used
    transitprint(1,verblevel,
		 "You are using one point atmospheric conditions:\n"
		 " Temperature: %g K\n"
		 ,st_at.atm.t[0]);
    //Densities for all isotopes
    for(i=0;i<tr->n_i;i++)
      transitprint(1,verblevel,
		   " %s: density %8g g/cm3\n"
		   ,tr->isof[i].n,st_at.isov[i].d[0]);
    /* no extra isotopes for one point! 
    //Density and cross section for extra isotopes
    for(;i<tr->n_e;i++)
      transitprint(1,verblevel,
		   " %s: density %.8g g/cm3\tcross section %8g\n"
		   ,tr->isof[i].n,st_at.isov[i].d[0],
		   st_at.isov[i].c[0]);
    */

  }
  //Otherwise if info is to be taken from file.
  else{
  /* TD: atmosphere info retrieval */
    //If a filename was given check its existence and that it can be
    //opened.
    verbfileopen(th->f_atm,&tr->fp_atm,"Atmospheric info ");

    transiterror(TERR_CRITICAL,
		 "Read atmospheric data file not yet implemented!\n");
  }
  transitASSERT(tr->n_e>tr->n_i,
		"Uyuyuyy!, number of isotopes after extension (%i)\n"
		"is smaller than number of isotopes before that (%i)\n"
		,tr->n_e,tr->n_i);


  //Return succes and set progress indicator
  tr->pi|=TRPI_GETATM;
  return 0;
}

