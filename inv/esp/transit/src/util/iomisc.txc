/*
 * iomisc.c
 * iomisc.txc - Miscellaneous input/output utilities.
 *
 * Copyright (C) 2004 Patricio Rojo (pato@astro.cornell.edu)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 */

#include <util/iomisc.h>

char *linepad_break="-";
int printpad_columns=__PADTO_COLUMNS;

/* \fcnfh
   reads into 'line' from 'fp' up to 'max' characters, it check that the
   last character read is '\n', if not then it assumes error and calls
   errfcn with parameters 'max' and 'name'. If '\n' is found then it
   take it out from the returned value. the idea behind returning the
   first character is to quickly identify comment lines

   @returns 0 if end of file is reached while no characters were read
            first character read otherwise.
	    -1 should never be returned.
*/
inline char
fgetupto(char *line,	/* Where input is stored, it has to have
			   dimension 'max' */
	 int max, 		/* dimension of 'line' */
	 FILE *fp,		/* File pointer to read from */
	 void (*errfcn)(int,char *, int), /* Error funtion to call
					     in case a newline is
					     not the last
					     character read and we
					     reached 'max' */
	 char *name,	/* Second parameter with which errfcn is
			   going to be called */
	 int other)
{
  char *lp;
  int n=0;

  lp=fgets(line,max,fp);
  if(lp!=line)
    return 0;
  //'n' does not include `\0'
  while(*lp++)
    n++;

  if(n==0){
    fprintf(stderr,
	    "UYYUYUY!, this should had not happened ever, maybe\n"
	    "fgets() is not working?. File %s, line %i\n"
	    ,__FILE__,__LINE__);
    exit(EXIT_FAILURE);
  }

  if(line[n-1]=='\n'){
    line[--n]='\0';
    return *line;
  }

  errfcn(max,name,other);
  return -1;
}

/* \fcnfh
   get at most 'n' (indefinite if 0) double format numbers from 'str',
   they are separated by 'sep'. Allocate and store them in 'array'

   @returns number of converted values
            -x if there were 'x' fields separated by car instead of 'n'.
*/
int
getad(int n,			/* Number of float field to accept */
      char sep,			/* separation character */
      char *str,		/* String where to look for values */
      double **array)		/* Pointers to double value */
{
  char *ptr=str;
  int rn=1;

  switch(sep){
  default:
    if(!isdigit(sep)) break;
  case 'e': case 'E': case '.': case '-': case '+':
    fprintf(stderr,
	    "iomisc:: getnd: invalid separator '%c'. It cannot be a\n"
	    "digit, '+', '-', 'e', 'E', nor '.'\n"
	    ,sep);
    exit(EXIT_FAILURE);
  }

  do{
    if(*ptr==sep)
      rn++;
  }while(*ptr++);

  if(ptr-1==str)
    return 0;
  if (n&&rn!=n)
    return -rn;
  n=rn;
  *array=(double *)calloc(n,sizeof(double));

  for(rn=0;rn<n;rn++){
    (*array)[rn]=strtod(str,&ptr);

    while(*ptr!=sep)
      if(!*ptr++){
	if(rn!=n-1)
	  fprintf(stderr,
		  "iomisc:: getnd: the one with %f was not supposed to\n"
		  "be the last(%ith) field but it is in: %s\n"
		  ,(*array)[rn],n,str);
	else
	  break;
      }
    str=ptr+1;
  }

  return rn;
}

/* \fcnfh
   get 'n' double format numbers from 'str', they are separated by
   'sep'. There is no way to know which of the 'n' were really
   converted. The non-converted doubles are returned untouched.

   @returns number of converted values
            -x if there were only 'x' fields separated by car instead 
	       of 'n'.
*/
int
getnd(int n,			/* Number of float field to accept */
      char sep,			/* separation character. If it is a
				   space, then it also accept tabs as
				   separation character */
      char *str,		/* String where to look for values */
      ...)			/* Pointers to double value */
{
  char *ptr=str;
  int rn=1,nc=0;
  double out,*in;
  va_list ap;

  switch(sep){
  default:
    if(!isdigit(sep)) break;
  case 'e': case 'E': case '.': case '-': case '+':
    fprintf(stderr,
	    "iomisc:: getnd: invalid separator '%c'. It cannot be a\n"
	    "digit, '+', '-', 'e', 'E', nor '.'\n"
	    ,sep);
    exit(EXIT_FAILURE);
  }

  do{
    if(*ptr==sep||(sep==' '&&*ptr=='\t'))
      rn++;
  }while(*ptr++);
  if(ptr-1==str)
    return 0;
  if (rn<n)
    return -rn;
  va_start(ap,str);
  for(rn=0;rn<n;rn++){
    in=(double *)va_arg(ap,double *);
    out=strtod(str,&ptr);
    if(str!=ptr){
      nc++;
      *in=out;
    }

    while(!(*ptr==sep||(sep==' '&&*ptr=='\t')))
      if(!*ptr++){
	if(rn!=n-1)
	  fprintf(stderr,
		  "iomisc:: getnd: the one with %f was not supposed to\n"
		  "be the last(%ith) field but it is in: %s\n"
		  ,out,n,str);
	else
	  break;
      }
    str=ptr+1;
  }
  va_end(ap);
  return nc;
}

/* \fcnfh
   get 'n' long format numbers from 'str', they are separated by
   'sep'. There is no way to know which of the 'n' were really
   converted. The non-converted doubles are returned untouched.

   @returns number of converted values
            -x if there were 'x' fields separated by car instead of 'n'.
*/
int
getnl(int n,			/* Number of long fields to accept */
      char sep,			/* separation character. If it is a
				   space, then it also accept tabs as
				   separation character */
      char *str,		/* String where to look for values */
      ...)			/* Pointers to long value */
{
  char *ptr=str;
  int rn=1,nc=0;
  long out,*in;
  va_list ap;

  switch(sep){
  default:
    if(!isdigit(sep)) break;
  case '-': case '+':
    fprintf(stderr,
	    "iomisc:: getnd: invalid separator '%c'. It cannot be a\n"
	    "digit, '+', nor '-'\n"
	    ,sep);
    exit(EXIT_FAILURE);
  }

  do{
    if(*ptr==sep||(sep==' '&&*ptr=='\t'))
      rn++;
  }while(*ptr++);
  if(ptr-1==str)
    return 0;
  if (rn!=n)
    return -rn;
  va_start(ap,str);
  for(rn=0;rn<n;rn++){
    in=(long *)va_arg(ap,long *);
    out=strtol(str,&ptr,0);
    if(str!=ptr){
      nc++;
      *in=out;
    }

    while(!(*ptr==sep||(sep==' '&&*ptr=='\t')))
      if(!*ptr++){
	if(rn!=n-1)
	  fprintf(stderr,
		  "iomisc:: getnl: the one with %li was not supposed to\n"
		  "be the last(%ith) field but it is in: %s\n"
		  ,out,n,str);
	else
	  break;
      }
    str=ptr+1;
  }
  va_end(ap);
  return nc;
}

/* \fcnfh
   Prints a parragraph with justification using linepad, it takes a indent
   value
*/
void
fprintpad(FILE *fp,		/* File pointer to print */
	  int indent,		/* Number of blanks to leave at the
				   beggining */ 
	  char *fmt,		/* format */
	  ...)			/* parameters */
{
  char *out,*ptr;
  int cols;
  int length=80,reall;
  va_list ap;

  out=getenv("COLUMNS");
  if(!out||!(cols=atoi(out)))
    cols=printpad_columns;
  if(indent>=cols)
    fprintf(stderr,
	    "iomisc::fprintpad(): Indent(%i) is bigger than columns(%i)\n"
	    ,indent,cols);

  char top[cols+1];

  out=(char *)calloc(length,sizeof(char));
  va_start(ap,fmt);
  reall=vsnprintf(out,length,fmt,ap);
  if(reall>=length){
    out=(char *)realloc(out,(reall+1)*sizeof(char));
    reall=vsnprintf(out,reall+1,fmt,ap);
  }
  va_end(ap);

  ptr=out;
  fprintf(stderr,"%*s",indent,"");
  while((ptr=linepad(top,cols-indent,ptr))){
    fprintf(stderr,"%s\n",top);
    fprintf(stderr,"%*s",indent,"");
  }
  fprintf(stderr,"%s",top);

}


/* \fcnfh
   read a double value

   @returns 0 on success
            first character read if it was not appropiate
*/
double readd(FILE *fp,
	     char *c)
{
  char *str,*cur,car;
  int salloc=8;
  _Bool atleast=0;
  enum {ent=0x1,dec=0x2,man=0x4,unsig=0x8} stage=ent|unsig;

  cur=str=(char *)calloc(salloc,sizeof(char));

  fflush(fp);
  tcflush(fileno(fp),TCIFLUSH);
  while(fread(&car,1,1,fp)){
    if(cur-str==salloc){
      cur=(str=(char *)realloc(str,(salloc<<1)*sizeof(char)))+salloc;
      salloc<<=1;
    }
    *cur=car;
    if(car=='\n')
      break;
    if(car=='e'||car=='E'){
      if(!atleast||stage&man)
	break;
      stage=man|unsig;
    }
    else if(car=='+'||car=='-'){
      if(!stage&unsig)
	break;
      stage&=~unsig;
    }
    else if(car=='.'){
      if(!stage&ent)
	break;
      stage=dec;
    }
    else if(isdigit(car)){
      atleast=1;
      stage&=~unsig;
    }
    else
      break;

    cur++;
  }
  while(fread(&car,1,1,fp))
    if(car=='\n')
      break;

  if(!atleast){
    if(c) *c=*cur;
    return 0;
  }
  *cur='\0';
  if(c) *c=0;
  return atof(str);
}


/* \fcnfh
   Align a line by adding spaces in between words, returns a pointer to
   the position right after the the last word. All newlines and tabs are
   cosidered spaces. It doesn't add a newline at the end of lines.

@returns pointer to the beggining of new word
         NULL if all is processed, in this case it doesn't do alignement.
*/
char *
linepad(char *out,		/* output, it has to have a length of at
				   least nc+1 */
	int nc,			/* number of columns */
	char *in)		/* input array */
{
  //word count 'wc' initializes to zero, it will be counting
  //interspaces.'out' index 'o' also initialize to zero.
  int wc=0,o=0,lasto=0;
  _Bool prev;
  out[nc]='\0';

  while(o<nc){
    //\linlabel{lastline}
    if(!*in){
      out[o]='\0';
      return NULL;
    }
    if(*in==' '||*in=='\n'||*in=='\t'){
      if(!prev){
	wc++;
	out[o]=' ';
	lasto=o;
	prev=1;
      }
    }
    else{
      prev=0;
      out[o]=*in;
    }
    in++;
    o++;
  }
  //if there is only one word, which is larger than 'nc' then break with
  //the string 'linepad_break'.
  if(!lasto){
    o=strlen(linepad_break);
    strcpy(out+nc-o,linepad_break);
    return in-o;
  }
  //'out' is now in the last position before padding.
  out+=lasto-1;
  out[1]='\0';
  //'lasto' now has the number of spaces that need to be added. 'in'
  //points to the beggining of the first non-processed word in the input
  //array
  lasto=nc-lasto;
  in-=lasto-1;
  wc--;

  while(lasto){
    //if there are spaces to add, but only a single word, then something
    //weird happened, this should have been noticed in \lin{lastline}
    if(!wc){
      fprintf(stderr,
	      "paralign:: critical error, no spaces, no end\n"
	      "of string, but spaces are to be addded\n");
      exit(EXIT_FAILURE);
    }
    //if space found, then add 'lasto'/'wc' (+1 if they were not an
    //exact ratio) extra spaces before this word. Diminish 'lasto' by
    //those many spaces and 'wc' by 1.
    if(*out==' '){
      o=(int)((float)lasto/wc--+0.999999999999);
      while(o--)
	out[lasto--]=' ';
    }
    out[lasto]=*out;
    out--;
  }

  return in;
}

