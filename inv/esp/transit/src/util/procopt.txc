/*
 * procopt.c
 * procopt.txc - Practical command line option parsing
 *
 * Copyright (C) 2004 Patricio Rojo (pato@astro.cornell.edu)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 */

#include <util/procopt.h>

//variables that are going to have allocated a space
static char *prgname=NULL;
static struct option *getopts;
static char *shortopts;
static char *line=NULL;
static char **paramfiles=NULL;

static struct optdocs *_opts;
static struct optcfg *_cfg;

unsigned short procopt_debug=1;
static _Bool freed=0;
static int givenparamf=-1;

static int getoptfrom(char *line, struct option *getopts, int *longindex);


/* \fcnfh
   Process comand line parameters. It process paramfile parameters and
   then the command line parameters. Changing name of parameter file
   have to be arranged before this function
*/
int
getprocopt(int argc,		/* Number of command line arguments */
	   char **argv,		/* Command line parameters */
	   struct optdocs *opts, /* structure with information about
				    parameter options and syntax */
	   struct optcfg *cfg,	/* various configuration parameters for
				   procopt */
	   int *longidxp)	/* return longindexp. Seems to be not
				   working in libraries!, though */
{
  char *cfgfiles=NULL;

  if(freed){
    fprintf(stderr,
	    "procopt:: getprocopt() was called after a call to\n"
	    "getpropt_free(), which should be the very last {procopt}\n"
	    "function called\n");
    exit(EXIT_FAILURE);
  }

  //If first time then initialize
  if(!prgname){
    int getalloc=8,shortalloc=8;
    struct option *co;
    char *cs;
    int getn,shortn;

    //save structures to later call by prochelp
    _opts=opts;
    _cfg=cfg;

    if((cs=rindex(*argv,'/')))
      cs++;
    else
      cs=*argv;
    prgname=(char *)calloc(strlen(cs)+1,sizeof(char));
    strcpy(prgname,cs);

    //If there is no 'opts' structure then allocate an empty string as
    //'shortopts' and an empty structure for 'getopts'
    if(!opts){
      getopts=(struct option *)calloc(1,sizeof(struct option));
      shortopts=(char *)calloc(1,sizeof(char));
    }

    //otherwise look for the right values
    else{
      co=getopts=(struct option *)calloc(getalloc,sizeof(struct option));
      cs=shortopts=(char *)calloc(shortalloc,sizeof(char));
      //getn starts at zero, but 'shortn' starts at 1 because it has to
      //reserve a value for the final `\\0' and a possible colon `:'
      getn=0;
      shortn=2;
      //Analize every element of the structure
      while(1){
	if(getn==getalloc){
	  getopts=(struct option *)realloc(getopts,
					   (getalloc<<=1)*sizeof(struct option));
	  co=getopts+getn;
	}
	if(shortn>shortalloc){
	  shortopts=(char *)realloc(shortopts,(shortalloc<<=1)*sizeof(char));
	  memset(shortopts+shortn,0,shortn);
	}
	if(opts->name==NULL&&opts->val==0){
	  if(opts++->has_arg==HELPTITLE)
	    continue;
	  break;
	}

	//save short options
	if(opts->val>0x20 && opts->val<0x80){
	  cs=shortopts;
	  while(*cs){
	    if(*cs++==(char)opts->val&&procopt_debug){
	      fprintf(stderr,
		      "procopt_debug error:: The short option '%c' appears more than\n"
		      "once in the given 'struct optdocs'. Currently with %s\n"
		      ,opts->val,opts->name);
	      exit(EXIT_FAILURE);
	    }
	  }
	  *cs++=(char)opts->val;
	  shortn++;
	  if(opts->has_arg==required_argument||opts->has_arg==ADDPARAMFILE){
	    *cs=':';
	    shortn++;
	  }
	}

	//save long option
	co->name=opts->name;
	if(opts->has_arg==ADDPARAMFILE){
	  if(givenparamf!=-1&&procopt_debug){
	    fprintf(stderr,
		    "procopt_debug error:: More than one option with the ADDPARAMFLAG\n"
		    "mode, only the last will be taken into account\n"
		    );
	    exit(EXIT_FAILURE);
	  }
	  co->has_arg=required_argument;
	  givenparamf=opts->val;
	}
	else
	  co->has_arg=opts->has_arg;
	co->flag=NULL;
	co->val=opts->val;

	//advance to next value
	getn++;
	opts++;
	co++;
      }
      if(procopt_debug>2){
	fprintf(stderr,
		"----------------------------------------------\n"
		"procopt_debug message:: Accepted short string '%s'\n"
		"(set procopt_debug to less than 3 if you don't want to see this again).\n"
		"----------------------------------------------\n"
		,shortopts);
      }
      co->name=NULL;
      co->has_arg=0;
      co->flag=NULL;
      co->val=0;
      getn++;
      getopts=(struct option *)realloc(getopts,getn*sizeof(struct option));
      shortopts=(char *)realloc(shortopts,(shortn-1)*sizeof(char));
    }
    if(cfg)
      cfgfiles=cfg->files;
  }

  //Return the corresponding option.
  return getopt_long_files(argc,argv,shortopts,getopts,longidxp,cfgfiles);
}


/* \fcnfh
 Works as getopt_long except by the extra parameter 'paramfile' which
 can process long versions of options from a file in the format
 \begin{verb} long_option [=] value\end{verb}.
 Reordering of arguments is also done in the same way as getopt_long
 does.

 @return shortoption value as it would have been returned by
 getopt_long.
*/
int 
getopt_long_files(int argc,	/* number of arguments */
		char **argv,	/* agruments list */
		char *shortopts, /* short options accepted, format is
				    the same as getopt(). */
		struct option *getopts,	/* long options accepted, format
					   is the same as
					   getopt_long(). Although
					   optional arguments are not
					   supported */
		int *longidxp,	/* returns position in the array
				   getopts[] for the last selected
				   option */
		char *paramfilelist) /* List of files from which to
					process longoptions. Names are
					separated by commas. Value of
					this variable in the first call
					to this function, is the only
					one that matters. */
{
  static FILE *fp=NULL;
  static char **parampointer;
  int ret;

  if(freed){
    fprintf(stderr,
	    "procopt:: getopt_long_files() was called after a call to\n"
	    "getpropt_free(), which should be the very last {procopt}\n"
	    "function called\n");
    exit(EXIT_FAILURE);
  }

  //Allocate name storing array if it is first time this is called.
  if(!paramfiles)
    parampointer=paramfiles=splitnzero_alloc(paramfilelist,',');

  //process file if one is given and it was not finished
  if(*parampointer){
    //open file if it is first run.
    if(!fp)
      fp=fopen(*parampointer,"r");
    //if file is open then process next line
    if(fp){
      //skip empty lines and commented lines. If this is not the first
      //line read, free the array
      while(1){
	if(line)
	  free(line);
	//if we reach the end of line proceed with next default file or
	//go to command line values.
	if((line=fgets_alloc(fp,NULL))==NULL){
	  fclose(fp);
	  ++parampointer;
	  return getopt_long_files(argc,argv,shortopts,getopts,
				 longidxp,NULL);
	}
	if(*line&&*line!='#')
	  break;
      }
      //If line was read succesfully, find if option exist and set
      //optarg 
      ret=getoptfrom(line,getopts,longidxp);
    }
    //if file was not opened then is because it doesn't exists. So,
    //continue with next one.
    else{
      ++parampointer;
      return getopt_long_files(argc,argv,shortopts,getopts,
			       longidxp,NULL);
    }
  }
  //If file didn't exist, was not given or is finished processing then
  //process command line parameters
  else
    ret= getopt_long(argc,argv,shortopts,getopts,longidxp);

  //If the option was to process a new parameter file then do that. That
  //option is hence never returned out of this function.
  if(givenparamf>=0&&ret==givenparamf){
    ret=parampointer-paramfiles;
    splitnzero_add(&paramfiles,optarg,',');
    parampointer=paramfiles+ret;
    if(*parampointer==NULL&&*optarg!='\0'){
      fprintf(stderr,
	      "procopt internal error: parampointer is null despite\n"
	      "having added a new file.\n");
      exit(EXIT_FAILURE);
    }

    return getopt_long_files(argc,argv,shortopts,getopts,
			     longidxp,NULL);
  }

  return ret;
}


/* \fcnfh
   Gives command line summary
*/
void
prochelp(int status)		/* either 'EXIT_FAILURE' or
				   'EXIT_SUCCESS' */
{
  char *options="[options]";
  char *intro=" Where [options] are...";
  char *contintro="----------------------------------\n"
    "Contact Information: %s\n";
  int indentdoc=21;
  int procopt_columns=(_cfg&&_cfg->columns)?_cfg->columns:__PADTO_COLUMNS;
  int currind,tmp;
  char *doc;
  int cols;
  char *pretitle=(_cfg&&_cfg->pretitle)?(char *)_cfg->pretitle:"\n";
  char *posttitle=(_cfg&&_cfg->posttitle)?(char *)_cfg->posttitle:"\n";
  char *postoption=(_cfg&&_cfg->postoption)?(char *)_cfg->postoption:".\n";

  if(freed){
    fprintf(stderr,
	    "procopt:: prochelp() was called after a call to\n"
	    "getpropt_free(), which should be the very last {procopt}\n"
	    "function called\n");
    exit(EXIT_FAILURE);
  }
  if(!prgname&&procopt_debug>1){
    fprintf(stderr,
	    "----------------------------------------------\n"
	    "procopt_debug warning:: Prochelp was called before getprocopt and\n"
	    "hence there are no available help\n"
	    "(set procopt_debug to less than 2 if you don't want to see this again).\n"
	    "----------------------------------------------\n"
	    );
  }

  doc=getenv("COLUMNS");
  if(!doc||!(cols=atoi(doc)))
    cols=procopt_columns;

  char out[cols+1];

  if(_cfg&&_cfg->indentdoc)
    indentdoc=_cfg->indentdoc;

  if(!prgname){
    fprintf(stderr,
	    "procopt error:: prochelp() was called with status %i\n"
	    "before a call to getprocopt()\n\n"
	    ,status);
    exit(EXIT_FAILURE);
  }

  if(_cfg)
    fprintf(stderr,"Usage:\n\t%s %s"
	    ,_cfg->prg?_cfg->prg:prgname
	    ,_cfg->options?_cfg->options:options);
  else
    fprintf(stderr,"Usage:\n\t%s %s"
	    ,prgname,options);

  if(_cfg&&_cfg->nonopt)
    fprintf(stderr," %s",_cfg->nonopt);


  //process options now
  fprintf(stderr,"\n\n");
  if(_opts){

    //print intro
    if(_cfg&&_cfg->intro)
      fprintf(stderr," %s\n",_cfg->intro);
    else
      fprintf(stderr," %s\n",intro);

    //process each option
    while(1){
      currind=0;
      if(_opts->has_arg==HELPTITLE)
	fprintf(stderr,"%s%s%s",pretitle,_opts->doc,posttitle);
      else if(_opts->name==NULL&&_opts->val==0)
	break;
      else{
	//if short form is of a printable character
	if(_opts->val>0x20 && _opts->val<0x80){
	  fprintf(stderr," -%c",_opts->val);
	  if(_opts->has_arg==required_argument||_opts->has_arg==ADDPARAMFILE)
	    fprintf(stderr," <%s>%n",_opts->prm,&currind);
	  else if(_opts->has_arg!=no_argument){
	    fprintf(stderr,
		    "\n\nprocopt error:: a non-supported value (%i) was given\n"
		    "in .has_arg field of parameter '%c'\n"
		    ,_opts->has_arg,_opts->val);
	    exit(EXIT_FAILURE);
	  }
	  currind+=2;
	}
	//stop if it is not printable and there is no long alternative
	else if(!_opts->name){
	  fprintf(stderr,
		  "\n\nprocopt error:: in prochelp() only a non displayable\n"
		  "value was given (val: %i). Parameter name is '%s' and\n"
		  "document help is:\n%s\n"
		  ,_opts->val,_opts->prm,_opts->doc);
	  exit(EXIT_FAILURE);
	}
	//print long version if there is one
	if(_opts->name){
	  if(currind)
	    fprintf(stderr,"\n");
	  fprintf(stderr," --%s%n",_opts->name,&currind);
	  tmp=0;
	  if(_opts->has_arg==required_argument||_opts->has_arg==ADDPARAMFILE)
	    fprintf(stderr," <%s>%n",_opts->prm,&tmp);
	  else if(_opts->has_arg!=no_argument){
	    fprintf(stderr,
		    "\n\nprocopt error:: a non-supported value (%i) was given\n"
		    "in .has_arg field of parameter '%s'\n"
		    ,_opts->has_arg,_opts->name);
	    exit(EXIT_FAILURE);
	  }
	  currind+=tmp;
	}
	//'tmp' is now spaces to indentation, and 'currind' is either the
	//'indentdoc' or wherever the pre-indent ends.
	tmp=indentdoc-currind;
	if(tmp>0){
	  fprintf(stderr,"%*s",tmp,"");
	  currind+=tmp;
	  tmp=0;
	}
	else{
	  fprintf(stderr," ");
	  tmp=1;
	}

	//print info if available
	if((doc=_opts->doc)){
	  while((doc=linepad(out,cols-currind-tmp,doc))){
	    tmp=0;
	    fprintf(stderr,"%s\n",out);
	    fprintf(stderr,"%*s",indentdoc,"");
	    currind=indentdoc;
	  }
	}
	else{
	  if(_cfg&&_cfg->noinfo){
	    strncpy(out,_cfg->noinfo,cols);
	    out[cols]='\0';
	  }
	  else{
	    strncpy(out,"(No info available)",cols);
	    out[19]='\0';
	  }
	}
	fprintf(stderr,"%s%s",out,postoption);
      }
      _opts++;

    }
  }

  if(_cfg&&_cfg->contact)
    fprintf(stderr,_cfg->contintro?_cfg->contintro:contintro
	    ,_cfg->contact);

  exit(status);
}


/* \fcnfh
   Mimics getopt_long (assuming always '.flags' equal to 0, but looking
   in line for a field like as 'name value'

   @returns 'val' from field in the struct option that contain the
                  right name
	    '?'   if name is an unknown option
	    ':'   if there is a missing parameter
*/
static int
getoptfrom(char *line,		/* line that should be of the form
				   'name value' */
	   struct option *getopt, /* array of the same form as the one
				       required for getopt_long */
	   int *longindex)	/* if not NULL, it points to a variable
				   which is set to the index of the long
				   option relative to longopts */
{
  char *opt;
  int index=0,flen,ret;

  opt=line;

  while(*opt&&*opt!=' '&&*opt!='\t')
    opt++;
  flen=opt-line;
  while(*opt==' '||*opt=='\t')
    opt++;

  ret='?';

  //search for each parameter
  while(getopt->name||getopt->has_arg||getopt->flag||getopt->val){
    if(getopt->name&&strncmp(getopt->name,line,flen)==0){
      if(longindex) 
	*longindex=index;
      switch(getopt->has_arg){
      case required_argument:
	if(*opt){
	  optarg=opt;
	  ret=getopt->val;
	}
	else
	  ret=':';
	break;
      case no_argument:
	ret=getopt->val;
	break;
      default:
	fprintf(stderr,
		"procopt:: Error in has_arg option at function\n"
		"getoptfrom(), which is called by getopt_long_files\n"
		"or getprocopt. Only required_argument or no_argument\n"
		"are accepted now\n");
	exit(EXIT_FAILURE);
      }
      break;
    }
    index++;
    getopt++;
  }

  return ret;
}


/* \fcnfh
   Frees all the memory allocated. This have to be called after any
   other call to getprocopt. Otherwise, because of the argv reordering
   everything will be mixed up.
 */
void
getprocopt_free()
{
  if(freed){
    fprintf(stderr,
	    "procopt:: getprocopt_free() was called twice\n");
    exit(EXIT_FAILURE);
  }

  //variables that are going to have allocated a space
  free(prgname);
  free(getopts);
  free(shortopts);
  if(line) free(line);
  splitnzero_free(paramfiles);
}
